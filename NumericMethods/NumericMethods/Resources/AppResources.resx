<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Menu_LinearEquation" xml:space="preserve">
    <value>Równania liniowe</value>
  </data>
  <data name="Menu_NonLinearEquation" xml:space="preserve">
    <value>Funkcje nieliniowe</value>
  </data>
  <data name="Menu_Interpolation" xml:space="preserve">
    <value>Interpolacja</value>
  </data>
  <data name="Menu_Integral" xml:space="preserve">
    <value>Całkowanie numeryczne</value>
  </data>
  <data name="Menu_DifferentialEquation" xml:space="preserve">
    <value>Równania różniczkowe</value>
  </data>
  <data name="Menu_AboutApp" xml:space="preserve">
    <value>O aplikacji</value>
  </data>
  <data name="LinearChart_AxisXDescription" xml:space="preserve">
    <value>x</value>
  </data>
  <data name="LinearChart_AxisYDescription" xml:space="preserve">
    <value>y</value>
  </data>
  <data name="LinearChart_LegendTitle" xml:space="preserve">
    <value>Funkcje</value>
  </data>
  <data name="NonLinearChart_LegendTitle" xml:space="preserve">
    <value>Funkcja</value>
  </data>
  <data name="NonLinearChart_Function" xml:space="preserve">
    <value>y₀ = {0}</value>
  </data>
  <data name="LinearChart_FirstFunction" xml:space="preserve">
    <value>y₁ = {0}</value>
  </data>
  <data name="LinearChart_SecondFunction" xml:space="preserve">
    <value>y₂ = {0}</value>
  </data>
  <data name="Common_Ok" xml:space="preserve">
    <value>OK</value>
  </data>
  <data name="IntegralPage_UpperLimit" xml:space="preserve">
    <value>1. Podaj górną granicę całkowania</value>
  </data>
  <data name="IntegralPage_LowerLimit" xml:space="preserve">
    <value>2. Podaj dolną granicę całkowania</value>
  </data>
  <data name="IntegralPage_Formula" xml:space="preserve">
    <value>3. Podaj wzór funkcji</value>
  </data>
  <data name="IntegralPage_Precision" xml:space="preserve">
    <value>4. Wybierz dokładność całkowania</value>
  </data>
  <data name="NonLinearEquation_Precision" xml:space="preserve">
    <value>Wybierz dokładność metody obliczającej</value>
  </data>
  <data name="IntegralPage_Precision_PickerTitle" xml:space="preserve">
    <value>Wybierz poziom dokładności</value>
  </data>
  <data name="IntegralPage_CustomPrecision" xml:space="preserve">
    <value>5. Podaj własną dokładność całkowania</value>
  </data>
  <data name="Common_Calculate" xml:space="preserve">
    <value>Oblicz</value>
  </data>
  <data name="Common_Ups" xml:space="preserve">
    <value>Ups!</value>
  </data>
  <data name="Common_SomethingWentWrong" xml:space="preserve">
    <value>Coś poszło nie tak</value>
  </data>
  <data name="Common_WrongFunction" xml:space="preserve">
    <value>Twoja funkcja zawiera błędy. Spróbuj jeszcze raz!</value>
  </data>
  <data name="Validation_FieldEmpty" xml:space="preserve">
    <value>Pole nie może być puste</value>
  </data>
  <data name="Validation_FormulaIsNotValid" xml:space="preserve">
    <value>Wzór funkcji zawiera błędy</value>
  </data>
  <data name="Validation_InvalidBorder" xml:space="preserve">
    <value>Górna granica całkowania musi być większa niż dolna granica</value>
  </data>
  <data name="Validation_CustomPrecisionIsEmpty" xml:space="preserve">
    <value>Wartość dokładności całkowania nie może być pusta</value>
  </data>
  <data name="Common_Result" xml:space="preserve">
    <value>Wynik</value>
  </data>
  <data name="FunctionResponse_UnclosedParentheses_Message" xml:space="preserve">
    <value>Twoja funkcja zawiera niezamknięte nawiasy. Spróbuj jeszcze raz.</value>
  </data>
  <data name="FunctionResponse_DivideByZero_Message" xml:space="preserve">
    <value>Dzielenie przez zero jest niedozwolone.</value>
  </data>
  <data name="FunctionResponse_WrongFunction_Message" xml:space="preserve">
    <value>Twoja funkcja zawiera błędy, które należy poprawić.</value>
  </data>
  <data name="Common_InputData" xml:space="preserve">
    <value>Wprowadź dane</value>
  </data>
  <data name="Common_Chart" xml:space="preserve">
    <value>Wykres</value>
  </data>
  <data name="Common_InvalidFunction" xml:space="preserve">
    <value>Błędna funkcja</value>
  </data>
  <data name="Common_InvalidFunction_Message" xml:space="preserve">
    <value>Funkcja nie może przyjmować kilku wartości dla jednego argumentu.</value>
  </data>
  <data name="Common_Help" xml:space="preserve">
    <value>Pomoc</value>
  </data>
  <data name="HelpPage_Power" xml:space="preserve">
    <value>2. Aby użyć potęgi we wzorze, konieczne jest użycie znaku ^. Przykładowy wzór funkcji: x^4+7x^2-4</value>
  </data>
  <data name="EquationService_Consistency" xml:space="preserve">
    <value>Układ sprzeczny</value>
  </data>
  <data name="EquationService_Equivalence" xml:space="preserve">
    <value>Układ nieoznaczony</value>
  </data>
  <data name="Common_NoOperations" xml:space="preserve">
    <value>Nie zostanie wykonana żadna operacja</value>
  </data>
  <data name="Common_NoSolutions" xml:space="preserve">
    <value>Brak rozwiązań</value>
  </data>
  <data name="NonLinearChartPage_ZeroPlot" xml:space="preserve">
    <value>y = 0</value>
  </data>
    <data name="EquationsNumberPopup_Placeholder" xml:space="preserve">
    <value>Ilość niewiadomych</value>
  </data>
  <data name="EquationsNumberPopup_Description" xml:space="preserve">
    <value>Wybierz ilość niewiadomych w równaniach</value>
  </data>
  <data name="LinearChartPopup_Placeholder" xml:space="preserve">
    <value>Ilość liczb</value>
  </data>
  <data name="LinearChartPopup_Description" xml:space="preserve">
    <value>Wybierz ile liczb całkowitych ma wchodzić w skład dziedziny</value>
  </data>
  <data name="AboutPopup_Header" xml:space="preserve">
    <value>Twórcami aplikacji są studenci z grupy 5:</value>
  </data>
  <data name="AboutPopup_Igor" xml:space="preserve">
    <value>Igor Kowalewski</value>
  </data>
  <data name="AboutPopup_Dominik" xml:space="preserve">
    <value>Dominik Guziałek</value>
  </data>
  <data name="AboutPopup_Mariusz" xml:space="preserve">
    <value>Mariusz Jackowski</value>
  </data>
  <data name="AboutPopup_Bartosz" xml:space="preserve">
    <value>Bartosz Mróz</value>
  </data>
  <data name="AboutPopup_OxyPlotDescription" xml:space="preserve">
    <value>Do rysowania wykresów została użyta darmowa biblioteka </value>
  </data>
  <data name="AboutPopup_IconsDescription" xml:space="preserve">
    <value>Wykorzystano ikonki pochodzące z zasobów serwisu </value>
  </data>
  <data name="AboutPopup_Year" xml:space="preserve">
    <value>© 2019</value>
  </data>
  <data name="Common_Cancel" xml:space="preserve">
    <value>Anuluj</value>
  </data>
  <data name="Common_Confirm" xml:space="preserve">
    <value>Zastosuj</value>
  </data>
  <data name="LoaderView_LoadingText" xml:space="preserve">
    <value>Trwa obliczanie...</value>
  </data>
  <data name="Common_X" xml:space="preserve">
    <value>x = </value>
  </data>
  <data name="Common_Y" xml:space="preserve">
    <value>y = </value>
  </data>
  <data name="DifferentialEquationPage_Formula" xml:space="preserve">
    <value>Podaj wzór równania, którego wartość różniczki ma zostać obliczona</value>
  </data>
  <data name="DifferentialEquationPage_Argument" xml:space="preserve">
    <value>Podaj argument, dla którego ma zostać obliczona wartość różniczki: </value>
  </data>
  <data name="DifferentialEquationPage_InitialValues" xml:space="preserve">
    <value>Podaj wartości początkowe</value>
  </data>
  <data name="IntegralHelp_Header" xml:space="preserve">
    <value>Całkowanie numeryczne - pomoc</value>
  </data>
  <data name="IntegralHelp_Description" xml:space="preserve">
    <value>Moduł pozwala na wyliczenie wartości całki oznaczonej. Obliczenia dokonywane są metodą trapezów oraz metodą prostokątów.</value>
  </data>
  <data name="IntegralHelp_FirstStep" xml:space="preserve">
    <value>1. Należy pamiętać, że dolna granica całkowania musi być mniejsza niż górna granica. W innym przypadku obliczenia nie zostaną dokonane.</value>
  </data>
    <data name="IntegralHelp_ThirdStep" xml:space="preserve">
    <value>3. We wzorze funkcji możliwe jest użycie: liczby Eulera (e), liczby Pi (π), funkcji trygonometrycznych (sin,cos,tan,ctg) oraz logarytmu naturalnego (ln). Przykładowa funkcja: 4e+π+x^4-ln[x]+3sin^3[x^3]</value>
  </data>
  <data name="IntegralHelp_FourthStep" xml:space="preserve">
    <value>4. Możliwa jest zmiana ilości iteracji metody na własną. W tym celu jako dokładność całkowania należy wybrać opcję 'Własna...' i wpisać liczbę iteracji. Maksymalną ilością iteracji jest 999999</value>
  </data>
  <data name="DifferentialHelp_Header" xml:space="preserve">
    <value>Równania różniczkowe - pomoc</value>
  </data>
  <data name="DifferentialHelp_Description" xml:space="preserve">
    <value>Moduł pozwala na wyliczenie wartości różniczki dy/dx wybranej funkcji, dla wskazanego argumentu. Obliczenia dokonywane są metodą Eulera oraz algorytmem Rungego-Kutty</value>
  </data>
  <data name="DifferentialHelp_FirstStep" xml:space="preserve">
    <value>1. We wzorze funkcji możliwe jest użycie dwóch zmiennych tj. x i y. Możliwe jest też ich mnożenie za pomocą znaku * np. x*4y</value>
  </data>
  <data name="DifferentialHelp_ThirdStep" xml:space="preserve">
    <value>3. Konieczne jest podanie wartości początkowych x i y. W razie pozostawienia pól pustymi, za wartość początkową zostanie przyjęte x = 0 i y = 0</value>
  </data>
  <data name="DifferentialHelp_FourthStep" xml:space="preserve">
    <value>4. Konieczne jest podanie argumentu, dla którego ma zostać obliczona wartość różniczki.</value>
  </data>
  <data name="DifferentialHelp_FifthStep" xml:space="preserve">
    <value>5. Możliwa jest zmiana dokładności metody obliczającej. Dla niskiej dokładności wartość kroku to 0.125, dla średniej dokładności to 0.025, a dla wysokiej dokładności to 0.005</value>
  </data>
  <data name="EquationHelp_Header" xml:space="preserve">
    <value>Równania liniowe - pomoc</value>
  </data>
  <data name="EquationHelp_Description" xml:space="preserve">
    <value>Moduł pozwala rozwiązać układ równań z maksymalnie czterema niewiadomymi. Do rozwiązania układu używana jest metoda Cramera.</value>
  </data>
  <data name="EquationHelp_FirstStep" xml:space="preserve">
    <value>1. Aby zmienić liczbę równań należy kliknąć przycisk w górnym prawym rogu.</value>
  </data>
  <data name="EquationHelp_SecondStep" xml:space="preserve">
    <value>2. Możliwe jest tylko wpisywanie liczb rzeczywistych w wyznaczone pola.</value>
  </data>
  <data name="EquationHelp_ThirdStep" xml:space="preserve">
    <value>3. Jeżeli pole nie zostanie wypełnione, do obliczeń w tym miejscu zostanie przyjęte 0</value>
  </data>
  <data name="EquationHelp_FourthStep" xml:space="preserve">
    <value>4. Po rozwiązaniu układu równań dla dwóch niewiadomych, możliwe jest narysowanie ich wykresu, w celu graficznego potwierdzenia poprawności rozwiązania. W tym celu należy nacisnąć przycisk wykresu, na ekranie z rozwiązaniem układu</value>
  </data>
  <data name="EquationHelp_FifthStep" xml:space="preserve">
    <value>5. Aby zwiększyć dziedzinę wykresu funkcji, należy nacisnąć przycisk symbolizujący wykres funkcji w górnym prawym rogu i wybrać odpowiednią wartość. Domyślną wartością jest 50, co znaczy, że wykres będzie rysowany dla argumentów od -50 do 50.</value>
  </data>
  <data name="InterpolationHelp_Header" xml:space="preserve">
    <value>Interpolacja - pomoc</value>
  </data>
  <data name="InterpolationHelp_Description" xml:space="preserve">
    <value>Moduł pozwala na znalezienie wartości funkcji dla podanego argumentu. Wartość wyliczana jest na podstawie podanych punktów. Do obliczeń używane są metody: Lagrange'a oraz Aitkena</value>
  </data>
  <data name="InterpolationHelp_FirstStep" xml:space="preserve">
    <value>1. Aby dokonać wyliczenia konieczne jest podanie argumentu, dla którego ma zostać wyliczone wartość funkcji.</value>
  </data>
  <data name="InterpolationHelp_SecondStep" xml:space="preserve">
    <value>2. Minimalną ilością punktów koniecznych do dokonania wyliczenia są trzy punkty. Kolejne punkty można dodawać klikając plusa w górnym prawym rogu.</value>
  </data>
  <data name="InterpolationHelp_ThirdStep" xml:space="preserve">
    <value>3. Przy podawaniu punktów, niemożliwe jest dodanie dwóch lub większej ilości wartości dla tego samego argumentu, ponieważ jest to sprzeczne z definicją funkcji.</value>
  </data>
  <data name="InterpolationHelp_FourthStep" xml:space="preserve">
    <value>4. Po dokonaniu wyliczenia możliwe jest zaznaczenie punktów oraz rozwiązania, na układzie współrzędnych</value>
  </data>
  <data name="NonLinearEquationHelp_Header" xml:space="preserve">
    <value>Funkcje nieliniowe - pomoc</value>
  </data>
  <data name="NonLinearEquationHelp_Description" xml:space="preserve">
    <value>Moduł pozwala na znalezienie miejsc zerowych wielomianu dowolnego stopnia. Do obliczeń używane są metody: Newtona-Raphsona oraz Graeff'ego</value>
  </data>
  <data name="NonLinearEquationHelp_FirstStep" xml:space="preserve">
    <value>1. Wzory funkcji powinny zawierać tylko jedną niewiadomą - x</value>
  </data>
  <data name="NonLinearEquationHelp_ThirdStep" xml:space="preserve">
    <value>3. Możliwe jest użycie, we wzorze funkcji, liczby Eulera oraz liczby Pi. Przykładowy wzór funkcji: x^3+4e+π</value>
  </data>
  <data name="NonLinearEquationHelp_FourthStep" xml:space="preserve">
    <value>4. Aby zwiększyć dokładność metody Graeff'ego można ustalić ilość iteracji. Dla niskiej dokładności są to 2 iteracje, dla średniej dokładności (domyślnie) są to 4 iteracje, a dla wysokiej dokładnosci metoda wykonuje 8 iteracji.</value>
  </data>
  <data name="NonLinearEquationHelp_FifthStep" xml:space="preserve">
    <value>5. Po znalezieniu miejsc zerowych możliwe jest narysowanie wykresu funkcji w celu graficznego potwierdzenia poprawności rozwiązania. W tym celu należy nacisnąć przycisk 'Narysuj wykres'</value>
  </data>
  <data name="NonLinearEquationHelp_SixthStep" xml:space="preserve">
    <value>6. Aby zwiększyć dziedzinę wykresu funkcji, należy nacisnąć przycisk symbolizujący wykres funkcji w górnym prawym rogu i wybrać odpowiednią wartość. Domyślną wartością jest 50, co znaczy, że wykres będzie rysowany dla argumentów od -50 do 50.</value>
  </data>
  <data name="SolveNonLinearEquationPage_NewtonRaphsonSolution" xml:space="preserve">
    <value>Miejsce zerowe obliczone metodą Newtona-Raphsona:</value>
  </data>
  <data name="SolveNonLinearEquationPage_GraeffeSolution" xml:space="preserve">
    <value>Miejsca zerowe obliczone metodą Graeff'ego:</value>
  </data>
  <data name="SolveNonLinearEquationPage_GraeffeIterations" xml:space="preserve">
    <value>Ilość iteracji w metodzie Graeff'ego: </value>
  </data>
  <data name="Common_DrawPlot" xml:space="preserve">
    <value>Narysuj wykres</value>
  </data>
  <data name="SolveEquationPage_Solution" xml:space="preserve">
    <value>Rozwiązanie układu równań to:</value>
  </data>
  <data name="NonLinearEquationPage_Description" xml:space="preserve">
    <value>Podaj wzór funkcji, a aplikacja obliczy jej miejsca zerowe</value>
  </data>
  <data name="SolveDifferentialEquationPage_RungeKuttaSolution" xml:space="preserve">
    <value>Wartość obliczona algorytmem Rungego-Kutty:</value>
  </data>
  <data name="SolveDifferentialEquationPage_EulerSolution" xml:space="preserve">
    <value>Wartość obliczona algorytmem Eulera:</value>
  </data>
  <data name="SolveDifferentialEquationPage_StepValue" xml:space="preserve">
    <value>Wartość kroku dla obu algorytmów: </value>
  </data>
  <data name="InterpolationPage_Argument" xml:space="preserve">
    <value>Podaj argument, dla którego ma zostać obliczona wartość funkcji:</value>
  </data>
  <data name="InterpolationPage_Points" xml:space="preserve">
    <value>Podaj minimum trzy punkty należące do funkcji: </value>
  </data>
  <data name="SolveInterpolationPage_LagrangeSolution" xml:space="preserve">
    <value>Wynik interpolacji metodą Lagrange'a:</value>
  </data>
  <data name="SolveInterpolationPage_AitkenSolution" xml:space="preserve">
    <value>Wynik interpolacji metodą Aitken'a:</value>
  </data>
  <data name="SolveInterpolationPage_ForArgument" xml:space="preserve">
    <value>Dla x = </value>
  </data>
  <data name="SolveInterpolationPage_ArgumentValue" xml:space="preserve">
    <value> funkcja przyjmuje wartość y = </value>
  </data>
  <data name="SolveInterpolationPage_InterpolationPoints_FirstPart" xml:space="preserve">
    <value>Interpolacja dokonana na podstawie </value>
  </data>
  <data name="SolveInterpolationPage_InterpolationPoints_SecondPart" xml:space="preserve">
    <value> punktów</value>
  </data>
  <data name="SolveInterpolationPage_DrawPoints" xml:space="preserve">
    <value>Zaznacz punkty na wykresie</value>
  </data>
  <data name="IntegralResultPage_TrapezeSolution" xml:space="preserve">
    <value>Wartość całki obliczona metodą trapezów: </value>
  </data>
  <data name="IntegralResultPage_RectangleSolution" xml:space="preserve">
    <value>Wartość całki obliczona metodą prostokątów: </value>
  </data>
  <data name="IntegralResultPage_Parameters" xml:space="preserve">
    <value>Wartość całki została obliczona dla parametrów</value>
  </data>
  <data name="IntegralResultPage_UpperLimit" xml:space="preserve">
    <value>Górna granica całkowania: </value>
  </data>
  <data name="IntegralResultPage_LowerLimit" xml:space="preserve">
    <value>Dolna granica całkowania: </value>
  </data>
  <data name="IntegralResultPage_Precision" xml:space="preserve">
    <value>Dokładność całkowania: </value>
  </data>
</root>